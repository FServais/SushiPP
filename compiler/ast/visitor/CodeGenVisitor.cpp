#include "CodeGenVisitor.hpp"

#include <algorithm>
#include <sstream>
#include <stdexcept>

using namespace std;
using namespace visitor;
using namespace ast;
using namespace codegen;
using namespace symb;
using namespace inference;

CodeGenVisitor::CodeGenVisitor(SymbolTable<VariableInfo>& _variable_table,
							   SymbolTable<FunctionInfo>& _function_table,
							   TypeSymbolTable& _type_table,
							   settings::BuiltInFunctions& _built_in)
  : curr_module(builder.get_curr_module()),
  	variable_table(_variable_table),
  	function_table(_function_table),
  	type_table(_type_table),
  	built_in(_built_in)
{
	// add list and array runtime globals
	string array_type("struct.array_table"), // same name as the ones generated by clang
			list_type("struct.list_table"), // same name as the ones generated by clang
			array_table("..array_table"),
			list_table("..list_table");

	builder.get_variable_manager().insert_variable(array_type);
	builder.get_variable_manager().insert_variable(list_type);

	curr_module.set_list_table_type(list_type);
	curr_module.set_array_table_type(array_type);

	// add global types and variables
	curr_module.add_global_type(array_type, "type opaque");
	curr_module.add_global_type(list_type, "type opaque");
	curr_module.add_global_variable("..array_table", "internal global %struct.array_table* null, align 8");
	curr_module.add_global_variable("..list_table", "internal global %struct.list_table* null, align 8");

	// add declaration of runtime tables creation functions
	curr_module.add_declaration("create_array_table", Module::make_declare("create_array_table", "%struct.array_table*", {}));
	curr_module.add_declaration("create_list_table", Module::make_declare("create_list_table", "%struct.list_table*", {}));
	curr_module.function_is_used("create_array_table");
	curr_module.function_is_used("create_list_table");

	// add declaration of list allocation function
	curr_module.add_declaration("list_allocate_int", Module::make_declare("list_allocate_int", "i64", { "%struct.list_table*" }));
	curr_module.add_declaration("list_allocate_float", Module::make_declare("list_allocate_float", "i64", { "%struct.list_table*" }));
	curr_module.add_declaration("list_allocate_bool", Module::make_declare("list_allocate_bool", "i64", { "%struct.list_table*" }));
	curr_module.add_declaration("list_allocate_char", Module::make_declare("list_allocate_char", "i64", { "%struct.list_table*" }));
	curr_module.add_declaration("list_allocate_string", Module::make_declare("list_allocate_string", "i64", { "%struct.list_table*" }));

	// add declaration of array allocation function
	curr_module.add_declaration("array_allocate_int", Module::make_declare("array_allocate_int", "i64", { "%struct.array_table*, i64, i64*" }));
	curr_module.add_declaration("array_allocate_float", Module::make_declare("array_allocate_float", "i64", { "%struct.array_table*, i64, float*" }));
	curr_module.add_declaration("array_allocate_bool", Module::make_declare("array_allocate_bool", "i64", { "%struct.array_table*, i64, i1*" }));
	curr_module.add_declaration("array_allocate_char", Module::make_declare("array_allocate_char", "i64", { "%struct.array_table*, i64, i8*" }));
	curr_module.add_declaration("array_allocate_string", Module::make_declare("array_allocate_string", "i64", { "%struct.array_table*, i64, i64*" }));

	// add datastructureaccess
	curr_module.add_declaration("array_get_int", Module::make_declare("array_get_int" , "i64", {"%struct.array_table*, i64, i64"}));
	curr_module.add_declaration("array_get_float", Module::make_declare("array_get_float" , "float", {"%struct.array_table*, i64, i64"}));
	curr_module.add_declaration("array_get_bool", Module::make_declare("array_get_bool" , "i1", {"%struct.array_table*, i64, i64"}));
	curr_module.add_declaration("array_get_char", Module::make_declare("array_get_char" , "i8", {"%struct.array_table*, i64, i64"}));
	curr_module.add_declaration("array_get_string", Module::make_declare("array_get_string" , "i64", {"%struct.array_table*, i64, i64"}));

	// add make sequence
	curr_module.add_declaration("list_make_sequence", Module::make_declare("list_make_sequence", "i64", { "%struct.list_table*", "i64", "i64"}));
	curr_module.add_declaration("array_make_sequence", Module::make_declare("array_make_sequence", "i64", { "%struct.array_table*", "i64", "i64"}));

	// add reference counting function
	curr_module.add_declaration("list_add_reference", Module::make_declare("list_add_reference", "void", { "%struct.list_table*", "i64"}));
	curr_module.add_declaration("list_rm_reference", Module::make_declare("list_rm_reference", "void", { "%struct.list_table*", "i64"}));
	curr_module.add_declaration("array_add_reference", Module::make_declare("array_add_reference", "void", { "%struct.array_table*", "i64"}));
	curr_module.add_declaration("array_rm_reference", Module::make_declare("array_rm_reference", "void", { "%struct.array_table*", "i64"}));
	curr_module.function_is_used("list_add_reference");
	curr_module.function_is_used("list_rm_reference");
	curr_module.function_is_used("array_add_reference");
	curr_module.function_is_used("array_rm_reference");

	// add main function
	shared_ptr<typegen::Function> main_func(new typegen::Function(shared_ptr<typegen::Type>(new typegen::Int)));
    FunctionBlock function(builder.get_variable_manager(), "main", main_func);
    function.set_return("0");
    curr_module.add_function("main", function);

    // add initialization code to the main
    BasicBlock& main_block = curr_module.get_function("main").get_last_block();

    // fake type for matching function prototype
    shared_ptr<typegen::Type> fake_type(new typegen::Int);
    unique_ptr<Variable> atable_addr, ltable_addr;
    atable_addr = unique_ptr<Variable>(main_block.add_expression("call %struct.array_table* (...)* @create_array_table()", "added_array_table", fake_type));
    ltable_addr = unique_ptr<Variable>(main_block.add_expression("call %struct.list_table* (...)* @create_list_table()", "added_list_table", fake_type));
    main_block.add_expression("store %struct.array_table* " + atable_addr->str_value() + ", %struct.array_table** @..array_table, align 8");
    main_block.add_expression("store %struct.list_table* " + ltable_addr->str_value() + ", %struct.list_table** @..list_table, align 8");

	// set the current function so that the visitor starts writing in it
	curr_func_name = "main";

	// add the built-in functions
	for(auto& function : built_in)
	{
		string llvm_func_name = Module::get_llvm_function_name(function.first, true),
				func_type_name = type_table.unique_id_name(0, function.first);
		shared_ptr<typegen::Function> func_type = dynamic_pointer_cast<typegen::Function>(type_table.get_type(func_type_name));
		FunctionBlock curr_func(builder.get_variable_manager(), llvm_func_name, func_type);
		curr_module.add_declaration(function.first, curr_func, get<5>(function.second));
	}
}


/*****************************
 * 		Identifier token    *
 *****************************/

void CodeGenVisitor::visit( Identifier& token )
{
	cout << "Identifier" << endl;
	string name;
	if(function_table.symbol_exists(token.id()))
		name = type_table.unique_id_name(function_table.get_symbol_scope_id(token.id()), token.id());
	else if(variable_table.symbol_exists(token.id()))
		name = type_table.unique_id_name(variable_table.get_symbol_scope_id(token.id()), token.id());
	else
		throw std::logic_error("Symbol " + token.id() + " not found (scope : " + to_string(function_table.curr_scope_id()) + ")");

	shared_ptr<typegen::Type> type = type_table.get_type(name);

	Variable* v = new Variable(builder.get_variable_manager(), token.id(), type, true);
	add_return(v);
}


/*************************
 * 		Keyword token    *
 *************************/
void CodeGenVisitor::visit( K_Break& token )
{
	cout << "K_Break" << endl;

}


void CodeGenVisitor::visit( K_Continue& token )
{
	cout << "K_Continue" << endl;

}


void CodeGenVisitor::visit( Type_Int& token )
{
	cout << "Type_Int" << endl;

}


void CodeGenVisitor::visit( Type_Float& token )
{
	cout << "Type_Float" << endl;

}


void CodeGenVisitor::visit( Type_Char& token )
{
	cout << "Type_Char" << endl;

}


void CodeGenVisitor::visit( Type_String& token )
{
	cout << "Type_String" << endl;

}


void CodeGenVisitor::visit( Type_Array& token )
{
	cout << "Type_Array" << endl;

}


void CodeGenVisitor::visit( Type_List& token )
{
	cout << "Type_List" << endl;

}


void CodeGenVisitor::visit( Type_Bool& token )
{
	cout << "Type_Bool" << endl;

}



void CodeGenVisitor::visit( Type_Function& token )
{
	cout << "Type_Function" << endl;

}


/****************************
 * 		Operator token      *
 ****************************/

void CodeGenVisitor::visit( Op_Plus& token )
{
	cout << "Op_Plus" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_plus(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_plus(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_plus(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_plus(lhs, rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));

	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_Minus& token )
{
	cout << "Op_Minus" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_minus(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_minus(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_minus(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_minus(lhs, rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));

	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_Mult& token )
{
	cout << "Op_Mult" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_mult(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_mult(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_mult(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_mult(lhs, rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_Div& token )
{
	cout << "Op_Div" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_div(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_div(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_div(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_div(lhs, rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_Modulo& token )
{
	cout << "Op_Modulo" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_mod(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_mod(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_mod(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_mod(lhs, rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_Exponentiation& token )
{
	cout << "Op_Exponentiation" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_expon(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_expon(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_expon(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_expon(lhs, rhs));

	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));

	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);

	// signal that the exponential function is used
	curr_module.function_is_used("pow-int");
	curr_module.function_is_used("pow-float");
}


void CodeGenVisitor::visit( Op_UnaryMinus& token )
{
	cout << "Op_UnaryMinus" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_unminus( *(load_rhs)));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_unminus(rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_BitwiseOr& token )
{
	cout << "Op_BitwiseOr" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_or(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_or(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_or(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_bit_or(lhs, rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_BitwiseAnd& token )
{
	cout << "Op_BitwiseAnd" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_and(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_and(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_and(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_bit_and(lhs, rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_BitwiseXor& token )
{
	cout << "Op_BitwiseXor" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_xor(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_xor(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_xor(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_bit_xor(lhs, rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_BitwiseNot& token )
{
	cout << "Op_BitwiseNot" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_not( *(load_rhs)));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_bit_not(rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_LogicalOr& token )
{
	cout << "Op_LogicalOr" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_log_or(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_log_or(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_log_or(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_log_or(lhs, rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_LogicalAnd& token )
{
	cout << "Op_LogicalAnd" << endl;
visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_log_and(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_log_and(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_log_and(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_log_and(lhs, rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_LogicalNot& token )
{
	cout << "Op_LogicalNot" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_log_not( *(load_rhs)));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_log_not(rhs));


	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_CompLessThan& token )
{
	cout << "Op_CompLessThan" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_lt(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_lt(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_lt(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_cmp_lt(lhs, rhs));

	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_CompGreaterThan& token )
{
	cout << "Op_CompGreaterThan" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_gt(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_gt(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_gt(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_cmp_gt(lhs, rhs));

	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_CompLessEqual& token )
{
	cout << "Op_CompLessEqual" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_le(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_le(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_le(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_cmp_le(lhs, rhs));

	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_CompGreaterEqual& token )
{
	cout << "Op_CompGreaterEqual" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_ge(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_ge(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_ge(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_cmp_ge(lhs, rhs));

	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_CompEqual& token )
{
	cout << "Op_CompEqual" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_eq(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_eq(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_eq(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_cmp_eq(lhs, rhs));

	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_CompNotEqual& token )
{
	cout << "Op_CompNotEqual" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_neq(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_neq(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_cmp_neq(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_cmp_neq(lhs, rhs));

	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_LeftShift& token )
{
	cout << "Op_LeftShift" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_left_shift(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant())
	{
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_left_shift(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_left_shift(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_left_shift(lhs, rhs));

	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));



	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_RightShift& token )
{
	cout << "Op_RightShift" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

    if(lhs.is_variable() && rhs.is_variable())
    {
        unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_right_shift(*(load_lhs), *(load_rhs)));
    }
	else if(lhs.is_variable() && rhs.is_constant()){
		unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));
		result = dynamic_cast<Variable*>(block.create_op_right_shift(*(load_lhs), rhs));
	}
	else if(lhs.is_constant() && rhs.is_variable())
	{
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_right_shift(lhs, *(load_rhs)));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_right_shift(lhs, rhs));

	// Create the pointer that will contain the result
	Variable* container = new Variable(builder.get_variable_manager(), builder.get_variable_manager().insert_variable(result->get_name()), result->get_type(), true);

	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));


	Value* after_store = block.create_store(*result, *ptr);
	Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();
	pop();

	add_return(after_store_var);
}


void CodeGenVisitor::visit( Op_StringConcat& token )
{
	cout << "Op_StringConcat" << endl;

}


void CodeGenVisitor::visit( Op_PrefixIncrement& token )
{
	cout << "Op_PrefixIncrement" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& operand = get_return_value(0);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

	if(operand.is_variable())
	{
		unique_ptr<Value> load_operand(block.create_load(operand));
		result = dynamic_cast<Variable*>(block.create_op_pref_incr(*load_operand));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_pref_incr(operand));

	Value* after_store = block.create_store(*result, operand);
	//Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();

	add_return(after_store);
}


void CodeGenVisitor::visit( Op_PrefixDecrement& token )
{
	cout << "Op_PrefixDecrement" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& operand = get_return_value(0);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Variable* result;

	if(operand.is_variable())
	{
		unique_ptr<Value> load_operand(block.create_load(operand));
		result = dynamic_cast<Variable*>(block.create_op_pref_decr(*load_operand));
	}
	else
		result = dynamic_cast<Variable*>(block.create_op_pref_decr(operand));

	Value* after_store = block.create_store(*result, operand);
	//Variable* after_store_var = dynamic_cast<Variable*>(after_store);

	pop();

	add_return(after_store);

}


void CodeGenVisitor::visit( Op_PostfixIncrement& token )
{
	cout << "Op_PostfixIncrement" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& operand = get_return_value(0);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// Create variable which will store the value of the operand
	Variable tmp_post_incr(builder.get_variable_manager(), "tmp_post_incr", operand.get_type());
	unique_ptr<Value> tmp_ptr = unique_ptr<Value>(block.create_decl_var(tmp_post_incr));

	// Load the value
	unique_ptr<Value> value = unique_ptr<Value>(block.create_load(operand));

	// Store in the new pointer
	Variable* copy_ptr = dynamic_cast<Variable*>(block.create_store(*value, *tmp_ptr));

	unique_ptr<Variable> result;

	if(operand.is_variable())
	{
		unique_ptr<Value> load_operand(block.create_load(operand));
		result = unique_ptr<Variable>(dynamic_cast<Variable*>(block.create_op_post_incr(*load_operand)));
	}
	else
		result = unique_ptr<Variable>(dynamic_cast<Variable*>(block.create_op_post_incr(operand)));

	unique_ptr<Value> after_store = unique_ptr<Value>(block.create_store(*result, operand));
	pop();

	add_return(copy_ptr);


}


void CodeGenVisitor::visit( Op_PostfixDecrement& token )
{
	cout << "Op_PostfixDecrement" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& operand = get_return_value(0);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// Create variable which will store the value of the operand
	Variable tmp_post_incr(builder.get_variable_manager(), "tmp_post_incr", operand.get_type());
	unique_ptr<Value> tmp_ptr = unique_ptr<Value>(block.create_decl_var(tmp_post_incr));

	// Load the value
	unique_ptr<Value> value = unique_ptr<Value>(block.create_load(operand));

	// Store in the new pointer
	Variable* copy_ptr = dynamic_cast<Variable*>(block.create_store(*value, *tmp_ptr));

	unique_ptr<Variable> result;

	if(operand.is_variable())
	{
		unique_ptr<Value> load_operand(block.create_load(operand));
		result = unique_ptr<Variable>(dynamic_cast<Variable*>(block.create_op_post_decr(*load_operand)));
	}
	else
		result = unique_ptr<Variable>(dynamic_cast<Variable*>(block.create_op_post_decr(operand)));

	unique_ptr<Value> after_store = unique_ptr<Value>(block.create_store(*result, operand));
	pop();

	add_return(copy_ptr);
}


void CodeGenVisitor::visit( Op_Assignment& token )
{
	cout << "Op_Assignment" << endl;
	visit_children(token);


	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);

	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	Value* result = nullptr;

	if(rhs.is_variable())
	{
		unique_ptr<Value> loaded_rhs(block.create_load(rhs));

		// If it is an array, we have to update the reference counter
		if(lhs.get_type()->is_array() || lhs.get_type()->is_list())
		{
			string type = (lhs.get_type()->is_array()) ? "array" : "list";
			string struct_type_name = "%struct." + type + "_table";
			string table_name = "@.." + type + "_table";

			string array_table = "%" + block.create_load_raw(struct_type_name + "** " + table_name);
			string func_name = type + "_add_reference";

			stringstream call_line;
			call_line << "call void (" << struct_type_name << "*, i64)* @" << func_name << "(" << struct_type_name << "* " << array_table << ", i64 " << loaded_rhs->str_value() << ")";
			block.add_expression(call_line.str());

			stringstream store_line;
			store_line << "store i64 " << loaded_rhs->str_value() << ", i64*" << lhs.str_value();
			block.add_expression(store_line.str());

			if(lhs.get_type()->is_array())
				array_rm_ref_flags.add_flag(loaded_rhs->str_value(), function_table.curr_scope_id());
			else
				list_rm_ref_flags.add_flag(loaded_rhs->str_value(), function_table.curr_scope_id());

			result = new Variable(dynamic_cast<Variable&>(lhs));
		}
		else
			result = block.create_store(*loaded_rhs, lhs);
	}
	else
		result = block.create_store(rhs, lhs);

	pop();
	pop();

	add_return(result);
}


void CodeGenVisitor::visit( Op_AssignPlus& token )
{
	cout << "Op_AssignPlus" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// the left hand side is a variable
	unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));

	Variable* result;
    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_plus(*load_lhs, *load_rhs));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_plus(*load_lhs, rhs));

	Value* after_store = block.create_store(*result, lhs);

	pop();
	pop();

	add_return(after_store);
}


void CodeGenVisitor::visit( Op_AssignMinus& token )
{
	cout << "Op_AssignMinus" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// the left hand side is a variable
	unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));

	Variable* result;
    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_minus(*load_lhs, *load_rhs));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_minus(*load_lhs, rhs));

	Value* after_store = block.create_store(*result, lhs);

	pop();
	pop();

	add_return(after_store);
}


void CodeGenVisitor::visit( Op_AssignMult& token )
{
	cout << "Op_AssignMult" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// the left hand side is a variable
	unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));

	Variable* result;
    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_mult(*load_lhs, *load_rhs));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_mult(*load_lhs, rhs));

	Value* after_store = block.create_store(*result, lhs);

	pop();
	pop();

	add_return(after_store);
}


void CodeGenVisitor::visit( Op_AssignDiv& token )
{
	cout << "Op_AssignDiv" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// the left hand side is a variable
	unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));

	Variable* result;
    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_div(*load_lhs, *load_rhs));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_div(*load_lhs, rhs));

	Value* after_store = block.create_store(*result, lhs);

	pop();
	pop();

	add_return(after_store);
}


void CodeGenVisitor::visit( Op_AssignExpo& token )
{
	cout << "Op_AssignExpo" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// the left hand side is a variable
	unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));

	Variable* result;
    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_expon(*load_lhs, *load_rhs));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_expon(*load_lhs, rhs));

	Value* after_store = block.create_store(*result, lhs);

	pop();
	pop();

	add_return(after_store);
}


void CodeGenVisitor::visit( Op_AssignMod& token )
{
	cout << "Op_AssignMod" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// the left hand side is a variable
	unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));

	Variable* result;
    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_mod(*load_lhs, *load_rhs));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_mod(*load_lhs, rhs));

	Value* after_store = block.create_store(*result, lhs);

	pop();
	pop();

	add_return(after_store);
}


void CodeGenVisitor::visit( Op_AssignAnd& token )
{
	cout << "Op_AssignAnd" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// the left hand side is a variable
	unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));

	Variable* result;
    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_and(*load_lhs, *load_rhs));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_bit_and(*load_lhs, rhs));

	Value* after_store = block.create_store(*result, lhs);

	pop();
	pop();

	add_return(after_store);
}


void CodeGenVisitor::visit( Op_AssignOr& token )
{
	cout << "Op_AssignOr" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// the left hand side is a variable
	unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));

	Variable* result;
    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_or(*load_lhs, *load_rhs));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_bit_or(*load_lhs, rhs));

	Value* after_store = block.create_store(*result, lhs);

	pop();
	pop();

	add_return(after_store);
}


void CodeGenVisitor::visit( Op_AssignXor& token )
{
	cout << "Op_AssignXor" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// the left hand side is a variable
	unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));

	Variable* result;
    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_bit_xor(*load_lhs, *load_rhs));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_bit_xor(*load_lhs, rhs));

	Value* after_store = block.create_store(*result, lhs);

	pop();
	pop();

	add_return(after_store);
}


void CodeGenVisitor::visit( Op_AssignConcat& token )
{
	cout << "Op_AssignConcat" << endl;
	visit_children(token);

	// Get 2 arguments
	Value& rhs = get_return_value(0);
	Value& lhs = get_return_value(1);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// the left hand side is a variable
	unique_ptr<Value> load_lhs = unique_ptr<Value>(block.create_load(lhs));

	Variable* result;
    if(rhs.is_variable())
    {
		unique_ptr<Value> load_rhs = unique_ptr<Value>(block.create_load(rhs));
		result = dynamic_cast<Variable*>(block.create_op_str_conc(*load_lhs, *load_rhs));
    }
	else
		result = dynamic_cast<Variable*>(block.create_op_str_conc(*load_lhs, rhs));

	Value* after_store = block.create_store(*result, lhs);

	pop();
	pop();

	add_return(after_store);
}


/**************************
 * 		Constant token    *
 **************************/

void CodeGenVisitor::visit( ast::String& token )
{
	cout << "String" << endl;
	ConstantString* constant_string = new ConstantString(token.value());
	add_return(constant_string);
}


void CodeGenVisitor::visit( Character& token )
{
	cout << "Character" << endl;
	ConstantChar* constant_char = new ConstantChar(token.value());
	add_return(constant_char);
}

void CodeGenVisitor::visit( Integer& token )
{
	cout << "Integer" << endl;
	ConstantInt* constant_int = new ConstantInt(token.value());
	add_return(constant_int);
}

void CodeGenVisitor::visit( ast::Float& token )
{
	cout << "Float" << endl;
	ConstantFloat* constant_float = new ConstantFloat(token.value());
	add_return(constant_float);
}

void CodeGenVisitor::visit( ast::Bool& token )
{
	cout << "Bool" << endl;
	ConstantBool* constant_bool = new ConstantBool(token.value());
	add_return(constant_bool);
}


/**************************************
 * 		Datastructure non-terminal    *
 **************************************/

void CodeGenVisitor::visit( ast::Array& token )
{
	cout << "Array" << endl;

	// store all the elements into memory
	visit_children(token);

	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	size_t array_size;

	if(!token.empty_items()) // empty array
		array_size = dynamic_cast<ExpressionList&>(token.get_items()).nb_expressions();
	else
		array_size = 0;

	// get the Value containint the elements to store in the array
	vector<shared_ptr<Value>> array_elements = get_n_return_values(array_size);

	string ctype, llvmtype; // the c type and llvm of the array elements
	shared_ptr<typegen::Type> array_subtype(type_table.get_type(token.get_type_id())),
							  array_type(new typegen::List(array_subtype));

	switch(array_subtype->get_type())
	{
	case inference::FLOAT:
		ctype = "float";
		llvmtype = "float";
		break;
	case inference::CHAR:
		ctype = "char";
		llvmtype = "i8";
		break;
	case inference::BOOL:
		ctype = "bool";
		llvmtype = "i1";
		break;
	case inference::INT:
		ctype = "int";
		llvmtype = "i64";
		break;
	default:
		ctype = "string";
		llvmtype = "i64";
		break;
	}

	// load the address of the array table
	string array_table = block.create_load_raw("%struct.array_table** @..array_table"),
			alloc_func = "array_allocate_" + ctype,
			spp_push_func = "array-push-" + ctype,
			push_func = Module::get_llvm_function_name(spp_push_func, true),
			alloc_call = "call i64 (%struct.array_table*, i64, "+llvmtype+"*)* @" + alloc_func + "(%struct.array_table* %" + array_table + ", i64 0, i64* null)";

	// notify the module that the allocate function is used
	curr_module.function_is_used(alloc_func);
	curr_module.function_is_used(spp_push_func);

	// create the array
	unique_ptr<Variable> array_id(block.add_expression(alloc_call, "id", array_type));

	// add the elements in the array
	for(auto current_value : array_elements)
	{
		shared_ptr<Value> element_value; // the value to pass to the push function call

		if(current_value->is_variable())
			element_value = shared_ptr<Value>(block.create_load(*current_value));
		else
			element_value = current_value;

		string push_call = "call void (%struct.array_table*, i64, " + llvmtype + ")* @" + push_func +
						    "(%struct.array_table* %" + array_table + ", i64 " + array_id->str_value() +
						    ", " + llvmtype + " " + element_value->str_value() + ")";

			block.add_expression(push_call);
	}

	pop_n_return_values(array_size);

	// store the array id into memory
	unique_ptr<Variable> tmp_id_addr_var(new Variable(builder.get_variable_manager(), "tmp_id_addr", array_type));
	unique_ptr<Value> tmp_id_addr(block.create_decl_var(*tmp_id_addr_var));
	Value* id_addr = block.create_store(*array_id, *tmp_id_addr);
	add_return(id_addr);
}


void CodeGenVisitor::visit( ast::List& token )
{
	cout << "List" << endl;

	// store all the elements into memory
	visit_children(token);

	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	size_t list_size;

	if(!token.empty_items()) // empty list
		list_size = dynamic_cast<ExpressionList&>(token.get_items()).nb_expressions();
	else
		list_size = 0;

	// get the Value containint the elements to store in the list
	vector<shared_ptr<Value>> list_elements = get_n_return_values(list_size);

	string ctype, llvmtype; // the c type and llvm of the array elements
	shared_ptr<typegen::Type> list_subtype(type_table.get_type(token.get_type_id())),
							  list_type(new typegen::List(list_subtype));

	switch(list_subtype->get_type())
	{
	case inference::FLOAT:
		ctype = "float";
		llvmtype = "float";
		break;
	case inference::CHAR:
		ctype = "char";
		llvmtype = "i8";
		break;
	case inference::BOOL:
		ctype = "bool";
		llvmtype = "i1";
		break;
	case inference::INT:
		ctype = "int";
		llvmtype = "i64";
		break;
	default:
		ctype = "string";
		llvmtype = "i64";
		break;
	}

	// load the address of the list table
	string list_table = block.create_load_raw("%struct.list_table** @..list_table"),
			alloc_func = "list_allocate_" + ctype,
			spp_push_func = "list-push-back-" + ctype,
			push_func = Module::get_llvm_function_name(spp_push_func, true),
			alloc_call = "call i64 (%struct.list_table*)* @" + alloc_func + "(%struct.list_table* %" + list_table + ")";

	// notify the module that the allocate function is used
	curr_module.function_is_used(alloc_func);
	curr_module.function_is_used(spp_push_func);

	// create the list
	unique_ptr<Variable> list_id(block.add_expression(alloc_call, "id", list_type));

	// add the elements in the array
	for(auto current_value : list_elements)
	{
		shared_ptr<Value> element_value; // the value to pass to the push function call

		if(current_value->is_variable())
			element_value = shared_ptr<Value>(block.create_load(*current_value));
		else
			element_value = current_value;

		string push_call = "call void (%struct.list_table*, i64, " + llvmtype + ")* @" + push_func +
						    "(%struct.list_table* %" + list_table + ", i64 " + list_id->str_value() +
						    ", " + llvmtype + " " + element_value->str_value() + ")";

			block.add_expression(push_call);
	}

	pop_n_return_values(list_size);

	// store the list id into memory
	unique_ptr<Variable> tmp_id_addr_var(new Variable(builder.get_variable_manager(), "tmp_id_addr", list_type));
	unique_ptr<Value> tmp_id_addr(block.create_decl_var(*tmp_id_addr_var));
	Value* id_addr = block.create_store(*list_id, *tmp_id_addr);
	add_return(id_addr);
}


void CodeGenVisitor::visit( MakeSequenceList& token )
{
	cout << "MakeSequenceList" << endl;
	visit_children(token);

	// normally two symbol were pushed
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();
	vector<shared_ptr<Value>> range(get_n_return_values(2));

	shared_ptr<Value> begin, end;

	if(range[0]->is_variable())
		begin = shared_ptr<Value>(block.create_load(*range[0]));
	else
		begin = range[0];

	if(range[1]->is_variable())
		end = shared_ptr<Value>(block.create_load(*range[1]));
	else
		end = range[1];

	string list_table = block.create_load_raw("%struct.list_table** @..list_table"),
			makes_call = "call i64 (%struct.list_table*, i64, i64)* @list_make_sequence(%struct.list_table* %" + list_table +
						 ", i64 " + begin->str_value() + ", i64 " + end->str_value() + ")";

	curr_module.function_is_used("list_make_sequence");

	// create the list
	shared_ptr<typegen::Type> list_type(new typegen::List(begin->get_type()));
	unique_ptr<Variable> list_id(block.add_expression(makes_call, "id", list_type));

	// store the list id into memory
	unique_ptr<Variable> tmp_id_addr_var(new Variable(builder.get_variable_manager(), "tmp_id_addr", list_type));
	unique_ptr<Value> tmp_id_addr(block.create_decl_var(*tmp_id_addr_var));
	Variable* id_addr = dynamic_cast<Variable*>(block.create_store(*list_id, *tmp_id_addr));

	pop_n_return_values(2);
	add_return(id_addr);
}


void CodeGenVisitor::visit( MakeSequenceArray& token )
{
	cout << "MakeSequenceArray" << endl;
	visit_children(token);

	// normally two symbol were pushed
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();
	vector<shared_ptr<Value>> range(get_n_return_values(2));

	shared_ptr<Value> begin, end;

	if(range[0]->is_variable())
		begin = shared_ptr<Value>(block.create_load(*range[0]));
	else
		begin = range[0];

	if(range[1]->is_variable())
		end = shared_ptr<Value>(block.create_load(*range[1]));
	else
		end = range[1];

	string array_table = block.create_load_raw("%struct.array_table** @..array_table"),
			makes_call = "call i64 (%struct.array_table*, i64, i64)* @array_make_sequence(%struct.array_table* %" + array_table +
						 ", i64 " + begin->str_value() + ", i64 " + end->str_value() + ")";

	curr_module.function_is_used("array_make_sequence");

	// create the array
	shared_ptr<typegen::Type> array_type(new typegen::Array(begin->get_type()));
	unique_ptr<Variable> array_id(block.add_expression(makes_call, "id", array_type));

	// store the array id into memory
	unique_ptr<Variable> tmp_id_addr_var(new Variable(builder.get_variable_manager(), "tmp_id_addr", array_type));
	unique_ptr<Value> tmp_id_addr(block.create_decl_var(*tmp_id_addr_var));
	Variable* id_addr = dynamic_cast<Variable*>(block.create_store(*array_id, *tmp_id_addr));

	pop_n_return_values(2);
	add_return(id_addr);
}


/************************************
 * 		Declaration non-terminal    *
 ************************************/

void CodeGenVisitor::visit( DeclFunc& token )
{
	cout << "DeclFunc" << endl;
	int index = 0;

	// Visit 1st child : Identifier
	token.get_children().at(index)->accept(*this);

	Value& id = get_return_value(0);
	Variable& id_var = dynamic_cast<Variable&>(id);

	// Create new FunctionBlock
	string declared_function_name = id_var.get_name(),
			func_name_table = type_table.unique_id_name(function_table.get_curr_scope_id(), declared_function_name),
			llvm_func_name = Module::get_llvm_function_name(declared_function_name, built_in.count(declared_function_name));

	//typegen::Function* function_type = ;
	vector<string> params;

	if(token.contains_params())
		token.get_param_list().get_parameters_name(params);

	FunctionBlock function(builder.get_variable_manager(),
						   llvm_func_name,
						   dynamic_pointer_cast<typegen::Function>(type_table.get_type(func_name_table)),
						   params);

	pop();

	// Change "cursor" of the visitor to the new function
	string current_function = curr_func_name;
	curr_func_name = declared_function_name;
	curr_module.add_function(declared_function_name, function);

	// Fullfill it through the visit of the children
	token.get_scope().accept(*this);

	// Get back to previous block
	curr_func_name = current_function;
}


void CodeGenVisitor::visit( DeclVars& token )
{
	cout << "DeclVars" << endl;
	visit_children(token);
}


void CodeGenVisitor::visit( DeclVar& token )
{
	cout << "DeclVar" << endl;
	visit_children(token);

	// Expression
	Value& expr = get_return_value(0);

	// IDENTIFIER
	Value& id = get_return_value(1);

	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// Allocate in memory
	unique_ptr<Value> lhs(block.create_decl_var(id));
	//Variable* lhs_ptr = dynamic_cast<Variable*>(lhs.get());

	if(expr.is_variable())
	{
		// Get the value
		Variable& expr_cast = dynamic_cast<Variable&>(expr);
		unique_ptr<Value> expr_value = unique_ptr<Value>(block.create_load(expr_cast));

		// If it is an array, we have to update the reference counter
		if(expr_cast.get_type()->is_array() || expr_cast.get_type()->is_list())
		{
			string type = (expr_cast.get_type()->is_array()) ? "array" : "list";
			string struct_type_name = "%struct." + type + "_table";
			string table_name = "@.." + type + "_table";

			string table = "%" + block.create_load_raw(struct_type_name + "** " + table_name);
			string func_name = type + "_add_reference";

			stringstream line;
			line << "call void (" << struct_type_name << "*, i64)* @" << func_name << "(" << struct_type_name << "* " << table << ", i64 " << expr_value->str_value() << ")";
			block.add_expression(line.str());

			stringstream store_line;
			store_line << "store i64 " << expr_value->str_value() << ", i64*" << lhs->str_value();
			block.add_expression(store_line.str());

			if(expr_cast.get_type()->is_array())
				array_rm_ref_flags.add_flag(expr_value->str_value(), function_table.curr_scope_id());
			else
				list_rm_ref_flags.add_flag(expr_value->str_value(), function_table.curr_scope_id());
		}
		else
		{
			// Store temp variable in location of the pointer
			unique_ptr<Value> store = unique_ptr<Value>(block.create_store(*expr_value, *lhs));
		}
	}
	else
		unique_ptr<Value> store = unique_ptr<Value>(block.create_store(expr, *lhs));


	pop();
	pop();
}


void CodeGenVisitor::visit( ParamList& token )
{
	cout << "ParamList" << endl;
	visit_children(token);
}


void CodeGenVisitor::visit( Param& token )
{
	cout << "Param" << endl;
	// Only visit the first child
	token.get_children().at(0)->accept(*this);
}



/***********************************
 * 		Expression non-terminal    *
 ***********************************/

void CodeGenVisitor::visit( Expression& token )
{
	cout << "Expression" << endl;
	visit_children(token);
}


void CodeGenVisitor::visit( ast::ExpressionList& token )
{
	cout << "ExpressionList" << endl;
	visit_children(token);
}


void CodeGenVisitor::visit( ModifyingExpression& token )
{
	cout << "ModifyingExpression" << endl;
	visit_children(token);
}


void CodeGenVisitor::visit( DatastructureAccess& token )
{
	cout << "DatastructureAccess" << endl;
	visit_children(token);
	//is a constant
	Value& index = get_return_value(0);
	Value& tab = get_return_value(1);

	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();


	Variable* tab_id = dynamic_cast<Variable*>(block.create_load(tab));
	string array_table = block.create_load_raw("%struct.array_table** @..array_table");
	shared_ptr<typegen::Type> type = dynamic_cast<typegen::Array*>(tab_id->get_type().get())->get_param_type();

	string ctype, llvmtype;
	switch(type->get_type())
	{
		case inference::FLOAT:
			ctype = "float";
			llvmtype = "float";
			break;
		case inference::CHAR:
			ctype = "char";
			llvmtype = "i8";
			break;
		case inference::BOOL:
			ctype = "bool";
			llvmtype = "i1";
			break;
		case inference::INT:
			ctype = "int";
			llvmtype = "i64";
			break;
		default:
			ctype = "string";
			llvmtype = "i64";
			break;
	}
	string get_val;
	if(index.is_variable())
	{
		Variable* ind = dynamic_cast<Variable*>(block.create_load(index));
		get_val = "call "+ llvmtype +" (%struct.array_table*, i64, i64)* @array_get_"+ctype+"( %struct.array_table* %"+
			array_table + ", i64 " + tab_id->str_value() + ", i64 " + ind->str_value() + " )";
	}
	else
		get_val = "call "+ llvmtype +" (%struct.array_table*, i64, i64)* @array_get_"+ctype+"( %struct.array_table* %"+
			array_table + ", i64 " + tab_id->str_value() + ", i64 " + index.str_value() + " )";


	curr_module.function_is_used("array-get-"+ctype);

	Variable* ret = block.add_expression(get_val, "ret", type);
	// store the ret value into memory
	unique_ptr<Variable> tmp_ret_addr_var(new Variable(builder.get_variable_manager(), "tmp_ret_addr", type));
	unique_ptr<Value> tmp_ret_addr(block.create_decl_var(*tmp_ret_addr_var));
	Variable* id_addr = dynamic_cast<Variable*>(block.create_store(*ret, *tmp_ret_addr));
	pop();
	pop();

	add_return(id_addr);
}



/*************************************
 * 		FunctionCall non-terminal    *
 *************************************/

void CodeGenVisitor::visit( FuncCall& token )
{
	cout << "FuncCall" << endl;
	// Visit children :
	// - 1st child : IDENTIFIER
	// - 2nd child : Argument list -> get ID's
	visit_children(token);

	int nb_args = 0;
	if(token.contains_arglist())
		nb_args = token.get_arg_list().nb_args();

	vector<shared_ptr<Value>> args = get_n_return_values(nb_args);

	// Function name
	Value& id = get_return_value(args.size());
	Variable& id_var = dynamic_cast<Variable&>(id);
	string func_name = id_var.get_name();

	// the fonction needs to be declared
	curr_module.function_is_used(func_name);

	// Return type
	string func_name_table = type_table.unique_id_name(function_table.get_symbol_scope_id(func_name), func_name);

	shared_ptr<typegen::Function> func_type = dynamic_pointer_cast<typegen::Function>(type_table.get_type(func_name_table));

	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// Get values from arguments
	vector<shared_ptr<Value>> args_value;
	for(auto arg = args.begin() ; arg != args.end() ; ++arg)
	{
		shared_ptr<Value> arg_ptr = *arg;
		if(arg_ptr->is_constant())
			args_value.push_back(arg_ptr);
		else if(arg_ptr->is_variable())
		{
			shared_ptr<Variable> var = dynamic_pointer_cast<Variable>(arg_ptr);
			args_value.push_back(shared_ptr<Value>(block.create_load(*var)));
		}
	}

	string llvm_func_name = Module::get_llvm_function_name(func_name, built_in.count(func_name));
	codegen::Function function(func_type->get_ret_type(), llvm_func_name, args_value);
	Variable* add = nullptr;

	if(built_in.count(func_name))
		add = dynamic_cast<Variable*>(block.create_func_call(function, get<5>(built_in.at(func_name))));
	else
		add = dynamic_cast<Variable*>(block.create_func_call(function));

	pop_n_return_values(nb_args+1);

	// Create the pointer that will contain the result
	if(add == nullptr)
		return;
	Variable* var = new Variable(builder.get_variable_manager(),
								 builder.get_variable_manager().insert_variable(add->get_name()),
								 add->get_type(), true);

	unique_ptr<Variable> container = unique_ptr<Variable>(var);
	unique_ptr<Value> ptr = unique_ptr<Value>(block.create_decl_var(*container));

	Variable* after_store_var = dynamic_cast<Variable*>(block.create_store(*add, *ptr));

	add_return(after_store_var);
}


void CodeGenVisitor::visit( ArgList& token )
{
	cout << "ArgList" << endl;
	visit_children(token);
}


void CodeGenVisitor::visit( Argument& token )
{
	cout << "Argument" << endl;
	visit_children(token);
}


void CodeGenVisitor::visit( SoyFunc& token )
{
	cout << "SoyFunc" << endl;
	visit_children(token);
	// // Create new FunctionBlock
	// string function_name = token.get_name(),
	// 		func_name_table = type_table.unique_id_name(function_table.get_curr_scope_id(), declared_function_name),
	// 		llvm_func_name = Module::get_llvm_function_name(declared_function_name, built_in.count(declared_function_name));

	// //typegen::Function* function_type = ;
	// shared_ptr<typegen::Type> func_type = type_table.get_type(func_name_table);
	// vector<string> params;

	// if(token.contains_params())
	// 	token.get_params().get_parameters_name(params);

	// FunctionBlock function(builder.get_variable_manager(),
	// 					   llvm_func_name,
	// 					   dynamic_pointer_cast<typegen::Function>(func_type),
	// 					   params);

	// // Change "cursor" of the visitor to the new function
	// string current_function = curr_func_name;
	// curr_func_name = declared_function_name;
	// curr_module.add_function(declared_function_name, function);

	// // Fullfill it through the visit of the children
	// token.get_scope().accept(*this);

	// // Get back to previous block
	// curr_func_name = current_function;

	// // soy expression is an expression so a pointer should be returned on the stack
	// // allocate memory
	// create_load_raw("");block.create_load_raw(func_type->to_str() + "** " + table_name);




}

/********************************
 * 		Program non-terminal    *
 ********************************/

void CodeGenVisitor::visit( Program& token )
{
	cout << "Program" << endl;
	visit_children(token);
}


void CodeGenVisitor::visit( Scope& token )
{
	cout << "Scope" << endl;
	size_t id_scope = token.get_scope_id();

	function_table.move_to_scope(id_scope);
	variable_table.move_to_scope(id_scope);

	visit_children(token);

	// // cout << ">>> Array <<<" << endl;
	// // array_rm_ref_flags.print();
	// // cout << endl;
	//
	// // cout << ">>> List <<<" << endl;
	// // list_rm_ref_flags.print();
	// // cout << endl;
	//
	// // Add free of array/list
	// BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();
	// vector<string> array_vars_to_free = array_rm_ref_flags.pop_vars_at_scope(id_scope);
	//
	// // -> Array
	// string type = "array";
	// string struct_type_name = "%struct." + type + "_table";
	// string table_name = "@.." + type + "_table";
	//
	// string array_table = "%" + block.create_load_raw(struct_type_name + "** " + table_name);
	// string func_name = type + "_rm_reference";
	//
	// for(auto var : array_vars_to_free)
	// {
	// 	stringstream line;
	// 	line << "call void (" << struct_type_name << "*, i64)* @" << func_name << "(" << struct_type_name << "* " << array_table << ", i64 " << var << ")";
	// 	block.add_expression(line.str());
	// }
	//
	// vector<string> list_vars_to_free = array_rm_ref_flags.pop_vars_at_scope(id_scope);
	//
	// // -> List
	// type = "list";
	// struct_type_name = "%struct." + type + "_table";
	// table_name = "@.." + type + "_table";
	//
	// array_table = block.create_load_raw(struct_type_name + "** " + table_name);
	// func_name = type + "_rm_reference";
	//
	// for(auto var : list_vars_to_free)
	// {
	// 	stringstream line;
	// 	line << "call void (" << struct_type_name << "*, i64)* @" << func_name << "(" << struct_type_name << "* " << array_table << ", i64 " << var << ")";
	// 	block.add_expression(line.str());
	// }

	if(!function_table.is_root())
		function_table.move_to_parent_scope();

	if(!variable_table.is_root())
		variable_table.move_to_parent_scope();

}



/**********************************
 * 		Statement non-terminal    *
 **********************************/

void CodeGenVisitor::visit( Statement& token )
{
	cout << "Statement" << endl;
	visit_children(token);
}


void CodeGenVisitor::visit( Return& token )
{
	cout << "Return" << endl;
	//FunctionBlock& function = curr_module.get_function(curr_func_name);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();
	size_t id_scope = function_table.curr_scope_id();

	if(token.has_child())
	{
		// Child is Expression
		visit_children(token);


		// cout << ">>> Array <<<" << endl;
		// array_rm_ref_flags.print();
		// cout << endl;

		// cout << ">>> List <<<" << endl;
		// list_rm_ref_flags.print();
		// cout << endl;

		// Add free of array/list
		BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();
		vector<string> array_vars_to_free = array_rm_ref_flags.pop_vars_at_scope(id_scope);

		// -> Array
		string type = "array";
		string struct_type_name = "%struct." + type + "_table";
		string table_name = "@.." + type + "_table";

		string array_table = "%" + block.create_load_raw(struct_type_name + "** " + table_name);
		string func_name = type + "_rm_reference";

		for(auto var : array_vars_to_free)
		{
			stringstream line;
			line << "call void (" << struct_type_name << "*, i64)* @" << func_name << "(" << struct_type_name << "* " << array_table << ", i64 " << var << ")";
			block.add_expression(line.str());
		}

		vector<string> list_vars_to_free = array_rm_ref_flags.pop_vars_at_scope(id_scope);

		// -> List
		type = "list";
		struct_type_name = "%struct." + type + "_table";
		table_name = "@.." + type + "_table";

		array_table = block.create_load_raw(struct_type_name + "** " + table_name);
		func_name = type + "_rm_reference";

		for(auto var : list_vars_to_free)
		{
			stringstream line;
			line << "call void (" << struct_type_name << "*, i64)* @" << func_name << "(" << struct_type_name << "* " << array_table << ", i64 " << var << ")";
			block.add_expression(line.str());
		}


		Value& exp = get_return_value(0);
		if(exp.is_variable())
		{
			Variable& exp_var = dynamic_cast<Variable&>(exp);
			if(exp_var.is_pointer())
			{
				//shared_ptr<Value> return_value(function.get_last_block().create_load(exp_var));
				//function.set_return(return_value->str_value());
				shared_ptr<Value> return_value(block.create_load(exp_var));
				block.create_return(*return_value);
			}
			else
			{
				//function.set_return(exp.str_value());
				block.create_return(exp);
			}
		}
		else
		{
			//function.set_return(exp.str_value());
			block.create_return(exp);
		}


		pop();
	}
	else
	{
		// cout << ">>> Array <<<" << endl;
		// array_rm_ref_flags.print();
		// cout << endl;

		// cout << ">>> List <<<" << endl;
		// list_rm_ref_flags.print();
		// cout << endl;

		// Add free of array/list
		BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();
		vector<string> array_vars_to_free = array_rm_ref_flags.pop_vars_at_scope(id_scope);

		// -> Array
		string type = "array";
		string struct_type_name = "%struct." + type + "_table";
		string table_name = "@.." + type + "_table";

		string array_table = "%" + block.create_load_raw(struct_type_name + "** " + table_name);
		string func_name = type + "_rm_reference";

		for(auto var : array_vars_to_free)
		{
			stringstream line;
			line << "call void (" << struct_type_name << "*, i64)* @" << func_name << "(" << struct_type_name << "* " << array_table << ", i64 " << var << ")";
			block.add_expression(line.str());
		}

		vector<string> list_vars_to_free = array_rm_ref_flags.pop_vars_at_scope(id_scope);

		// -> List
		type = "list";
		struct_type_name = "%struct." + type + "_table";
		table_name = "@.." + type + "_table";

		array_table = block.create_load_raw(struct_type_name + "** " + table_name);
		func_name = type + "_rm_reference";

		for(auto var : list_vars_to_free)
		{
			stringstream line;
			line << "call void (" << struct_type_name << "*, i64)* @" << func_name << "(" << struct_type_name << "* " << array_table << ", i64 " << var << ")";
			block.add_expression(line.str());
		}

		//function.set_return("");
		block.add_expression("ret void");
	}

}


void CodeGenVisitor::visit( Menu& token )
{
	cout << "Menu" << endl;

	token.get_expression().accept(*this);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();
	FunctionBlock& curr_function = curr_module.get_function(curr_func_name);


	Value& val_to_switch = get_return_value(0);
	Variable* val = dynamic_cast<Variable*>(block.create_load(val_to_switch));
	string llvm_type = val->get_type()->to_str();

	MenuBody& son = token.get_body();

	string switch_jump;
	string def_lab = label_manager.insert_label("default");
	string end_lab = label_manager.insert_label("end");

	if(son.contains_default())
		switch_jump = "switch "+ llvm_type + " " + val->str_value() + ", label %"+def_lab ;
	else
		switch_jump = "switch "+ llvm_type + " " + val->str_value() + ", label %"+end_lab ;
	int nb_case = son.nb_cases();


	vector<string> case_lab;

	if(nb_case > 0)
	{

		switch_jump += "[ ";

		for(size_t i = 0; i < nb_case; i++)
		{

			(son.get_nth_case(i)).get_expression().accept(*this);

			Value& expr = get_return_value(0);

			string label = label_manager.insert_label("case");
			case_lab.push_back(label);

			if(expr.is_constant())
				switch_jump += llvm_type+" "+ expr.str_value() + ", label %"+label + " \n ";
			else
			{
				Variable* v = dynamic_cast<Variable*>(block.create_load(expr));
				switch_jump += llvm_type+" "+ v->str_value() + ", label %"+label + " \n ";
			}

			pop();

		}

		switch_jump += " ]";
	}
	string end = "br label %"+end_lab;
	block.add_expression(switch_jump);

	for( int i = 0; i < nb_case ; i ++)
	{
		curr_function.add_block(case_lab[i]);
		son.get_nth_case(i).get_scope().accept(*this);
		curr_module.get_function(curr_func_name).get_last_block().add_expression(end);
	}
	cout << "COU"<<son.contains_default()<<endl;
	if(son.contains_default())
	{
		curr_function.add_block(def_lab);
		son.get_default_case().accept(*this);
		curr_module.get_function(curr_func_name).get_last_block().add_expression(end);
	}

	curr_function.add_block(end_lab);


}

void CodeGenVisitor::visit( ast::MenuBody& )
{

}

void CodeGenVisitor::visit( MenuDef& token )
{
	cout << "MenuDef" << endl;
	visit_children(token);

}

void CodeGenVisitor::visit( MenuCase& token )
{
	cout << "MenuCase" << endl;

}

void CodeGenVisitor::visit( Roll& token )
{
	cout << "Roll" << endl;
	string begin_loop = label_manager.insert_label("begin_loop");
	string label_true = label_manager.insert_label("label_true");
	string label_false = label_manager.insert_label("label_false");
	string jump0 = "br label %"+begin_loop;
	BasicBlock& block0 = curr_module.get_function(curr_func_name).get_last_block();
	block0.add_expression(jump0);


	FunctionBlock& curr_function = curr_module.get_function(curr_func_name);
	curr_function.add_block(begin_loop);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	//calculate expression
	token.get_expression().accept(*this);
	Value& cond = get_return_value(0);
	string branch;
	if(cond.is_constant())
		branch = "br i1 "+ cond.str_value()+", label %"+label_true+" , label %"+label_false;
	else
	{
		Value* expr = block.create_load(cond);
		branch = "br i1 "+ expr->str_value()+", label %"+label_true+" , label %"+label_false;
	}
	block.add_expression(branch);
	curr_function.add_block(label_true);

	// body
	token.get_scope().accept(*this);
	string jump = "br label %"+begin_loop;
	BasicBlock& block2 = curr_module.get_function(curr_func_name).get_last_block();
	block2.add_expression(jump);

	curr_function.add_block(label_false);
	pop();


}


void CodeGenVisitor::visit( Foreach& token )
{
	cout << "Foreach" << endl;

}


void CodeGenVisitor::visit( For& token )
{
	cout << "For" << endl;
	string begin_loop = label_manager.insert_label("begin_loop");
	string label_true = label_manager.insert_label("label_true");
	string label_false = label_manager.insert_label("label_false");
	// init
	if(! token.empty_initializer())
		token.get_initializer().accept(*this);
	// jump to loop
	string jump0 = "br label %" + begin_loop;
	BasicBlock& block0 = curr_module.get_function(curr_func_name).get_last_block();
	block0.add_expression(jump0);

	// behin loop
	FunctionBlock& curr_function = curr_module.get_function(curr_func_name);
	curr_function.add_block(begin_loop);
	BasicBlock& block = curr_module.get_function(curr_func_name).get_last_block();

	// calculate guardian expression
	token.get_expression().accept(*this);
	Value& cond = get_return_value(0);

	// branch
	string branch;
	if(cond.is_constant())
		branch = "br i1 "+ cond.str_value()+", label %"+label_true+" , label %"+label_false;
	else
	{
		Value* expr = block.create_load(cond);
		branch = "br i1 "+ expr->str_value()+", label %"+label_true+" , label %"+label_false;
	}
	block.add_expression(branch);
	curr_function.add_block(label_true);

	// body
	token.get_scope().accept(*this);

	// update
	if(! token.empty_update())
		token.get_update().accept(*this);

	string jump = "br label %"+begin_loop;
	BasicBlock& block2 = curr_module.get_function(curr_func_name).get_last_block();
	block2.add_expression(jump);
	curr_function.add_block(label_false);

	pop();
}


void CodeGenVisitor::visit( ForInitializer& token )
{
	cout << "ForInitializer" << endl;
	visit_children(token);

}


void CodeGenVisitor::visit( ForUpdate& token )
{
	cout << "ForUpdate" << endl;
	visit_children(token);

}


void CodeGenVisitor::visit( Conditional& token )
{
	cout << "Conditional" << endl;
	FunctionBlock& curr_function = curr_module.get_function(curr_func_name);
	string end_if_label = label_manager.insert_label("end_if");

	token.get_if().accept(*this);

	for(int i = 0 ; i < token.count_elseif() ; ++i)
		token.get_nth_elseif(i).accept(*this);

	if(token.contains_else())
		token.get_else().accept(*this);
	else
		curr_function.get_last_block().create_branch(end_if_label);


	curr_function.add_block(end_if_label);
}

void CodeGenVisitor::visit( Elseif& token )
{
	cout << "Elseif" << endl;
	// In current block, add operations to compute the condition and the branch
	token.get_expression().accept(*this);
	Value& result_comp = top(); // Return the variable where the result is stored

	FunctionBlock& curr_function = curr_module.get_function(curr_func_name);
	BasicBlock& block = curr_function.get_last_block();

	string label_true = label_manager.insert_label("elseif_true");
	string label_false = label_manager.insert_label("elseif_false");
	block.create_cond_branch(result_comp, label_true, label_false);

	pop();

	string end_if_label = label_manager.get_last_occurence("end_if");

	// Create block "true"
	curr_function.add_block(label_true);

	// Add body of the block "true"
	token.get_scope().accept(*this);

	// Go to end_if
	curr_function.get_last_block().create_branch(end_if_label);

	// Create elseif_false
	curr_function.add_block(label_false);
}

void CodeGenVisitor::visit( ast::If& token )
{
	cout << "If" << endl;
	// In current block, add operations to compute the condition and the branch
	token.get_expression().accept(*this);
	Value& result_comp = top(); // Return the variable where the result is stored
	Variable& cast_result = dynamic_cast<Variable&>(result_comp);


	FunctionBlock& curr_function = curr_module.get_function(curr_func_name);
	BasicBlock& block = curr_function.get_last_block();

	// Load the value of the result of the comparison
	unique_ptr<Value>result_comp_value = unique_ptr<Value>(block.create_load(cast_result));

	string label_true = label_manager.insert_label("if_true");
	string label_false = label_manager.insert_label("if_false");
	block.create_cond_branch(*result_comp_value, label_true, label_false);

	pop();

	string end_if_label = label_manager.get_last_occurence("end_if");

	// Create block "true"
	curr_function.add_block(label_true);

	// Add body of the block "true"
	token.get_scope().accept(*this);

	// Go to end_if
	curr_function.get_last_block().create_branch(end_if_label);

	// Create if_false
	curr_function.add_block(label_false);
}

void CodeGenVisitor::visit( ast::Else& token )
{
	cout << "Else" << endl;
	token.get_scope().accept(*this);

	curr_module.get_function(curr_func_name).get_last_block().create_branch(label_manager.get_last_occurence("end_if"));
}



/************************
 * 		Default case    *
 ************************/
void CodeGenVisitor::visit( ASTNode& token )
{
	visit_children(token);
	cout << "Unknown node" << endl;
}


void CodeGenVisitor::visit_children( ASTNode& token )
{
	for(auto child : token.get_children())
		child->accept(*this);
}


void CodeGenVisitor::print(ostream& out)
{
	builder.dump(out);
}



/************************
 * 		   Vector       *
 ************************/

void CodeGenVisitor::add_return(Value* value)
{
	return_vector.push_back(unique_ptr<Value>(value));
}


Value& CodeGenVisitor::top()
{
	return *(return_vector[return_vector.size()-1]);
}

void CodeGenVisitor::pop()
{
	return_vector.erase(return_vector.begin()+return_vector.size()-1);
}


Value& CodeGenVisitor::get_return_value(int n)
{
	return *(return_vector.at(return_vector.size()-1-n));
}

void CodeGenVisitor::remove_return_value(int n)
{
	return_vector.erase(return_vector.begin()+return_vector.size()-1-n);
}

vector<shared_ptr<Value>> CodeGenVisitor::get_n_return_values(int n)
{
	vector<shared_ptr<Value>> values;
	copy(next(return_vector.begin(), return_vector.size() - n), return_vector.end(), back_inserter(values));
	return values;
}


void CodeGenVisitor::pop_n_return_values(int n)
{
	for(int i = 0 ; i < n ; ++i)
		pop();
}


bool CodeGenVisitor::is_vector_empty() const
{
	return get_vector_size() <= 0;
}

int CodeGenVisitor::get_vector_size() const
{
	return return_vector.size();
}
